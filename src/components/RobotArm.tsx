/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/models/gilberto_a_robot_arm2.glb -T -t -D 
Files: ./public/models/gilberto_a_robot_arm2.glb [585.86KB] > /Users/pampanie/dev/projects/3dworks/robot/robotop/gilberto_a_robot_arm2-transformed.glb [77.44KB] (87%)
*/

import * as THREE from 'three';
import { useMemo, useEffect, useState } from 'react';
import { useFrame, useGraph } from '@react-three/fiber';
import { useGLTF } from '@react-three/drei';
import { GLTF, SkeletonUtils } from 'three-stdlib';

type GLTFResult = GLTF & {
	nodes: {
		Object_Mesh: THREE.SkinnedMesh;
		_rootJoint: THREE.Bone;
	};
	materials: {};
	animations: THREE.AnimationClip[];
};

export function RobotArm(props: JSX.IntrinsicElements['group']) {
	const { scene } = useGLTF('models/gilberto_a_robot_arm2-transformed.glb');
	const clone = useMemo(() => SkeletonUtils.clone(scene), [scene]);
	const { nodes, materials } = useGraph(clone) as GLTFResult;
	const [targetPosition, setTargetPosition] = useState(
		new THREE.Vector3(0, 0, 0)
	);
	const [bones, setBones] = useState<THREE.Bone[]>([]);

	const setBoneLimits = (
		bone: THREE.Bone,
		limits: { min: THREE.Vector3; max: THREE.Vector3 }
	) => {
		bone.userData.rotationLimits = {
			min: limits.min,
			max: limits.max,
		};
	};

	useEffect(() => {
		const collectedBones: THREE.Bone[] = [];

		const traverseBones = (bone: THREE.Bone) => {
			collectedBones.push(bone);

			if (bone.userData.rotationLimits) {
				console.log(
					'Rotation limits for',
					bone.name,
					':',
					bone.userData.rotationLimits
				);
			}

			bone.children.forEach((child) => {
				if (child instanceof THREE.Bone) {
					traverseBones(child);
				}
			});
		};

		if (nodes._rootJoint) {
			traverseBones(nodes._rootJoint);
			setBones(collectedBones);
		}
	}, [nodes]);

	const computeBoneRotations = () => {
		const MAX_ITERATIONS = 10;
		const TOLERANCE = 0.01;
		const endEffector = bones[bones.length - 1];

		for (let i = 0; i < MAX_ITERATIONS; i++) {
			// Work backwards from end effector to root
			for (let j = bones.length - 1; j >= 0; j--) {
				const bone = bones[j];
				const currentPosition = new THREE.Vector3();
				endEffector.getWorldPosition(currentPosition);

				const directionToTarget = targetPosition.clone().sub(currentPosition);
				const directionToEndEffector = currentPosition
					.clone()
					.sub(bone.getWorldPosition(new THREE.Vector3()));

				const axis = new THREE.Vector3()
					.crossVectors(directionToEndEffector, directionToTarget)
					.normalize();

				const angle = directionToEndEffector.angleTo(directionToTarget);

				// Apply rotation while respecting limits
				if (bone.userData.rotationLimits) {
					const { min, max } = bone.userData.rotationLimits;
					const newRotation = bone.rotation.clone();
					const rotationChange = new THREE.Vector3(
						angle,
						angle,
						angle
					).multiply(axis);
					newRotation.set(
						newRotation.x + rotationChange.x,
						newRotation.y + rotationChange.y,
						newRotation.z + rotationChange.z
					);

					// Clamp rotation to limits
					newRotation.x = THREE.MathUtils.clamp(newRotation.x, min.x, max.x);
					newRotation.y = THREE.MathUtils.clamp(newRotation.y, min.y, max.y);
					newRotation.z = THREE.MathUtils.clamp(newRotation.z, min.z, max.z);

					bone.rotation.copy(newRotation);
				} else {
					bone.rotateOnWorldAxis(axis, angle);
				}
			}

			// Check if we've reached the target
			const currentEndPosition = new THREE.Vector3();
			endEffector.getWorldPosition(currentEndPosition);
			if (currentEndPosition.distanceTo(targetPosition) < TOLERANCE) {
				break;
			}
		}
	};

	useFrame((_) => {
		computeBoneRotations();
	});

	return (
		<group {...props} dispose={null} scale={[0.005, 0.005, 0.005]}>
			<primitive object={nodes._rootJoint} />
			<skinnedMesh
				geometry={nodes.Object_Mesh.geometry}
				material={nodes.Object_Mesh.material}
				skeleton={nodes.Object_Mesh.skeleton}
			/>
		</group>
	);
}

useGLTF.preload('models/gilberto_a_robot_arm2-transformed.glb');
